/**
 * é…ç½®åŒºåŸŸ
 */
const CONFIG = {
  // Notion é…ç½®
  NOTION_DATABASE_ID: "ä¿®æ”¹ä¸ºå¯¹åº”çš„NOTION_DATABASE_ID", 
  NOTION_API_KEY: "ä¿®æ”¹ä¸ºå¯¹åº”çš„NOTION_API_KEY",

  // Telegram é…ç½®
  TELEGRAM_BOT_TOKEN: "ä¿®æ”¹ä¸ºå¯¹åº”çš„TELEGRAM_BOT_TOKEN",
  ALLOWED_USER_IDS: ["ä¿®æ”¹ä¸ºå¯¹åº”çš„ALLOWED_USER_IDS"],

  // åŸºç¡€é…ç½®
  CITY: "Portland",
  STATE_FULL: "Oregon",
  ZIP_CODE: "97212"
};

export default {
  async fetch(request, env, ctx) {
    if (request.method === "GET") {
      const data = await handleRedfinAddress(null, true);
      return new Response(JSON.stringify(data, null, 2), { 
        headers: { "Content-Type": "application/json; charset=utf-8" } 
      });
    }

    if (request.method !== "POST") return new Response("Bot is running!", { status: 200 });

    try {
      const update = await request.json();

      // --- 1. é‰´æƒ ---
      const userId = getUserId(update);
      if (userId && !CONFIG.ALLOWED_USER_IDS.includes(String(userId))) {
        return new Response("Unauthorized", { status: 200 }); 
      }

      // --- 2. æ¶ˆæ¯å¤„ç† ---
      if (update.message && update.message.text) {
        const text = update.message.text.trim();
        const chatId = update.message.chat.id;

        if (text === "/start") {
          await sendWelcomeMenu(chatId);
        }
        else if (text === "ğŸ“¦ ç«‹å³å–å·" || text === "å–å·" || text === "/get") {
          await handleGetAccount(chatId);
        }
        else if (text === "ğŸ“Š æŸ¥è¯¢åº“å­˜" || text === "åº“å­˜" || text === "/stock") {
          await handleCheckStock(chatId);
        }
        else if (text === "ğŸ  éšæœºåœ°å€" || text === "åœ°å€" || text === "/address") {
          await handleRedfinAddress(chatId);
        }
      }
      
      // --- 3. æŒ‰é’®å›è°ƒå¤„ç† ---
      else if (update.callback_query) {
        await handleCallback(update.callback_query);
      }

    } catch (e) {
      console.error(e);
    }

    return new Response("OK", { status: 200 });
  }
};

// --- è¾…åŠ©å‡½æ•° ---
function getUserId(update) {
  if (update.message) return update.message.from.id;
  if (update.callback_query) return update.callback_query.from.id;
  return null;
}

// èœå•
async function sendWelcomeMenu(chatId) {
  const text = "ğŸ‘‹ æ¬¢è¿å›æ¥ï¼\n\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹æ“ä½œï¼š";
  const keyboard = {
    keyboard: [
      [{ text: "ğŸ“¦ ç«‹å³å–å·" }, { text: "ğŸ“Š æŸ¥è¯¢åº“å­˜" }],
      [{ text: "ğŸ  éšæœºåœ°å€" }]
    ],
    resize_keyboard: true,
    is_persistent: true
  };
  await sendMessage(chatId, text, keyboard);
}

// --- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ ---

// 1. å¤„ç†åœ°å€æŠ“å– (ğŸ‘‘ ç»ˆæé™ç»´æ‰“å‡»ç‰ˆï¼šOverpass API æ•°æ®åº“ç›´è¿)
async function handleRedfinAddress(chatId, isJsonOnly = false) {
  try {
    // ğŸ’¡ æ”¾å¼ƒæœç´¢ï¼Œæ”¹ä¸ºâ€œæ•°æ®åº“æ¡†é€‰â€
    // (45.530,-122.665,45.555,-122.615) æ˜¯å®Œç¾è¦†ç›– Portland 97212 çš„åœ°ç†çŸ©å½¢åæ ‡
    // æŸ¥è¯¢æŒ‡ä»¤ï¼šåœ¨è¿™ä¸ªçŸ©å½¢å†…ï¼Œæ‰¾å‡ºæ‰€æœ‰å¸¦æœ‰ addr:housenumber (é—¨ç‰Œå·) å’Œ addr:street (è¡—é“) çš„çœŸå®æˆ¿å±‹èŠ‚ç‚¹ï¼Œä¸€æ¬¡æå– 300 ä¸ª
    const bbox = "45.530,-122.665,45.555,-122.615";
    const overpassQuery = `[out:json];node(${bbox})["addr:housenumber"]["addr:street"];out 300;`;
    
    // ä½¿ç”¨å®˜æ–¹ä¸å¤‡ç”¨èŠ‚ç‚¹ï¼Œé˜²æ­¢å•ç‚¹æ•…éšœ
    const endpoints = [
        "https://overpass-api.de/api/interpreter",
        "https://lz4.overpass-api.de/api/interpreter"
    ];
    const apiUrl = `${endpoints[Math.floor(Math.random() * endpoints.length)]}?data=${encodeURIComponent(overpassQuery)}`;

    const response = await fetch(apiUrl, {
      headers: {
        // ç”Ÿæˆéšæœº User-Agent é˜²æ­¢è¢«è¯†åˆ«ä¸ºåŒä¸€æ¥æºé™åˆ¶
        "User-Agent": `TelegramAddressBot_CF_${Math.floor(Math.random()*100000)}`,
        "Accept": "application/json"
      }
    });

    if (!response.ok) {
        throw new Error(`API æ‹’ç»å“åº”: ${response.status}`);
    }

    const data = await response.json();
    const houses = data.elements;

    if (!houses || houses.length === 0) {
        throw new Error("åŒºåŸŸå†…æœªæå–åˆ°æœ‰æ•ˆå»ºç­‘æ•°æ®");
    }

    // --- æˆåŠŸè·å–ï¼---
    // ä»ä¸€æ¬¡æ€§æ‹¿åˆ°çš„ 300 å¥—çœŸå®æˆ¿å±‹ä¸­ï¼ŒéšæœºæŒ‘ä¸€å¥—
    const randomHouse = houses[Math.floor(Math.random() * houses.length)];
    const tags = randomHouse.tags;

    // ç²¾å‡†ç»„è£…åœ°å€
    const street = `${tags["addr:housenumber"]} ${tags["addr:street"]}`;
    const city = tags["addr:city"] || CONFIG.CITY;
    const state = "OR";
    const zip = tags["addr:postcode"] || CONFIG.ZIP_CODE;

    const fullAddr = `${street}, ${city}, ${state} ${zip}`;

    const result = {
      address: street,
      city: city,
      state: state,
      zip: zip,
      fullAddress: fullAddr
    };

    if (!isJsonOnly && chatId) {
      const msg = `ğŸ  <b>éšæœºæˆ¿æºåœ°å€</b>\n\nğŸ“ <code>${result.fullAddress}</code>`;
      await sendMessage(chatId, msg);
    }

    return result;

  } catch (e) {
    if (chatId) {
       await sendMessage(chatId, `âŒ <b>è·å–å¤±è´¥:</b> ${e.message} (è¯·ç¨åå†è¯•)`);
    }
    return { error: e.message };
  }
}

// 2. å¤„ç†å–å·
async function handleGetAccount(chatId) {
  const [page, stockCount] = await Promise.all([
    queryNotionUnused(), 
    getStockCount()      
  ]);

  if (!page) {
    return sendMessage(chatId, "âš ï¸ <b>åº“å­˜ä¸è¶³</b>ï¼šå½“å‰æ²¡æœ‰â€œæœªä½¿ç”¨â€çš„è´¦å·ã€‚");
  }

  const props = page.properties;
  const pageId = page.id;

  const account = props["è´¦å·"]?.formula?.string || props["è´¦å·"]?.rich_text?.[0]?.plain_text || props["è´¦å·"]?.title?.[0]?.plain_text || "æ— è´¦å·";
  const password = props["å¯†ç "]?.formula?.string || props["å¯†ç "]?.rich_text?.[0]?.plain_text || "æ— å¯†ç ";

  // è¯»å–åˆ›å»ºæ—¶é—´
  let createTimeRaw = props["åˆ›å»ºæ—¶é—´"]?.created_time || props["åˆ›å»ºæ—¶é—´"]?.date?.start || "æœªçŸ¥";
  let createTimeStr = "æœªçŸ¥";
  
  if (createTimeRaw !== "æœªçŸ¥") {
    const dateObj = new Date(createTimeRaw);
    createTimeStr = dateObj.toLocaleString('zh-CN', { 
      timeZone: 'Asia/Shanghai', 
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    }).replace(/\//g, '-');
  }

  const messageText = 
    `ğŸ“¦ <b>æå–æˆåŠŸï¼</b> (ğŸ“Š åº“å­˜: ${stockCount})\n\n` +
    `è´¦å·ï¼š<code>${account}</code>\n` +
    `å¯†ç ï¼š<code>${password}</code>\n` +
    `ç»„åˆï¼š<code>${account}----${password}</code>\n` + 
    `Xboxåˆ›å»ºæ—¶é—´ï¼š${createTimeStr}\n\n` +
    `ğŸ‘‡ <b>è¯·é€‰æ‹©æ“ä½œï¼š</b>`;

  const inlineKeyboard = {
    inline_keyboard: [
      [
        { text: "âœ… å…‘æ¢ç ", callback_data: `redeem|${pageId}` }, 
        { text: "ğŸ”˜ å…¶ä»–", callback_data: `other|${pageId}` }
      ],
      [
        { text: "âŒ å–æ¶ˆ", callback_data: `cancel|${pageId}` }
      ]
    ]
  };

  await sendMessage(chatId, messageText, inlineKeyboard);
}

// 3. å¤„ç†åº“å­˜æŸ¥è¯¢
async function handleCheckStock(chatId) {
  const count = await getStockCount();
  const text = `ğŸ“Š <b>åº“å­˜æŸ¥è¯¢ç»“æœ</b>\n\n` +
               `å½“å‰å‰©ä½™å¯ç”¨ç™½å·ï¼š<b>${count}</b> ä¸ª`;
  await sendMessage(chatId, text);
}

// 4. å¤„ç†æŒ‰é’®å›è°ƒ
async function handleCallback(query) {
  const [action, pageId] = query.data.split("|");
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;

  if (action === "cancel") {
    await deleteMessage(chatId, messageId);
    return;
  }

  let originalText = query.message.text || "";
  originalText = originalText.replace(/ğŸ‘‡.*/s, "").trim();

  // ğŸ”„ é‡æ–°ç»™è´¦å·ã€å¯†ç ã€ç»„åˆã€åœ°å€åŠ ä¸Š <code> æ ‡ç­¾
  originalText = originalText.replace(/(è´¦å·ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(å¯†ç ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(ç»„åˆï¼š)(.+)/, '$1<code>$2</code>'); 
  originalText = originalText.replace(/(ğŸ“)(.+)/, '$1<code>$2</code>'); 

  let newStatus = action === "redeem" ? "å…‘æ¢ç " : "å…¶ä»–";
  let statusText = action === "redeem" ? "âœ… <b>å·²æ ‡è®°ä¸ºï¼šå…‘æ¢ç </b>" : "ğŸ”˜ <b>å·²æ ‡è®°ä¸ºï¼šå…¶ä»–</b>";
  
  const nowStr = new Date().toLocaleString('zh-CN', { 
    timeZone: 'Asia/Shanghai', 
    hour12: false 
  });

  const success = await updateNotionPage(pageId, newStatus);

  if (success) {
    const finalText = `${originalText}\n\n${statusText}\nğŸ•’ <b>ä½¿ç”¨æ—¶é—´ï¼š</b>${nowStr}`;
    await editMessage(chatId, messageId, finalText);
    await answerCallback(query.id, "æ“ä½œæˆåŠŸï¼");
  } else {
    await answerCallback(query.id, "âŒ Notion æ›´æ–°å¤±è´¥");
  }
}

// --- Notion API ---

async function queryNotionUnused() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "filter": { "property": "çŠ¶æ€", "select": { "is_empty": true } }, // ä»…ç­›é€‰ç©ºçŠ¶æ€
      "sorts": [{ "property": "åˆ›å»ºæ—¶é—´", "direction": "ascending" }],
      "page_size": 1
    })
  });
  const data = await response.json();
  if (data.results && data.results.length > 0) return data.results[0];
  return null;
}

async function getStockCount() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
        "Notion-Version": "2022-06-28",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "filter": { "property": "çŠ¶æ€", "select": { "is_empty": true } }, // ä»…ç­›é€‰ç©ºçŠ¶æ€
        "page_size": 100 
      })
    });
    const data = await response.json();
    return data.results ? data.results.length : 0;
  } catch (e) {
    return "æœªçŸ¥";
  }
}

async function updateNotionPage(pageId, statusName) {
  const url = `https://api.notion.com/v1/pages/${pageId}`;
  const now = new Date().toISOString();
  const response = await fetch(url, {
    method: "PATCH",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "properties": {
        "çŠ¶æ€": { "select": { "name": statusName } },
        "ä½¿ç”¨æ—¥æœŸ": { "date": { "start": now } }
      }
    })
  });
  return response.ok;
}

// --- Telegram API ---

async function sendMessage(chatId, text, replyMarkup = null) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/sendMessage`;
  const body = { chat_id: chatId, text: text, parse_mode: "HTML" };
  if (replyMarkup) body.reply_markup = replyMarkup;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
}

async function deleteMessage(chatId, messageId) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/deleteMessage`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId }) });
}

async function editMessage(chatId, messageId, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/editMessageText`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId, text: text, parse_mode: "HTML" }) });
}

async function answerCallback(id, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/answerCallbackQuery`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ callback_query_id: id, text: text }) });
}
