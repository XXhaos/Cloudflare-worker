/**
 * é…ç½®åŒºåŸŸ
 */
const CONFIG = {
  // Notion é…ç½®
  NOTION_DATABASE_ID: "2dee5672038f80778f72e864c361a26a", 
  NOTION_API_KEY: "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",

  // Telegram é…ç½®
  TELEGRAM_BOT_TOKEN: "8247694128:AAEjkBuS-1ockjOmoW9LjHkHBO-t_Zy8BPE",
  ALLOWED_USER_IDS: ["1732587552"],

  // Redfin æŠ“å–é…ç½®
  REDFIN_URL: "https://www.redfin.com/zipcode/97212",
  CITY: "Portland",
  STATE_FULL: "Oregon",
  ZIP_CODE: "97212"
};

export default {
  async fetch(request, env, ctx) {
    if (request.method === "GET") {
      const data = await handleRedfinAddress(null, true);
      return new Response(JSON.stringify(data, null, 2), { 
        headers: { "Content-Type": "application/json; charset=utf-8" } 
      });
    }

    if (request.method !== "POST") return new Response("Bot is running!", { status: 200 });

    try {
      const update = await request.json();

      // --- 1. é‰´æƒ ---
      const userId = getUserId(update);
      if (userId && !CONFIG.ALLOWED_USER_IDS.includes(String(userId))) {
        return new Response("Unauthorized", { status: 200 }); 
      }

      // --- 2. æ¶ˆæ¯å¤„ç† ---
      if (update.message && update.message.text) {
        const text = update.message.text.trim();
        const chatId = update.message.chat.id;

        if (text === "/start") {
          await sendWelcomeMenu(chatId);
        }
        else if (text === "ğŸ“¦ ç«‹å³å–å·" || text === "å–å·" || text === "/get") {
          await handleGetAccount(chatId);
        }
        else if (text === "ğŸ“Š æŸ¥è¯¢åº“å­˜" || text === "åº“å­˜" || text === "/stock") {
          await handleCheckStock(chatId);
        }
        else if (text === "ğŸ  éšæœºåœ°å€" || text === "åœ°å€" || text === "/address") {
          await handleRedfinAddress(chatId);
        }
      }
      
      // --- 3. æŒ‰é’®å›è°ƒå¤„ç† ---
      else if (update.callback_query) {
        await handleCallback(update.callback_query);
      }

    } catch (e) {
      console.error(e);
    }

    return new Response("OK", { status: 200 });
  }
};

// --- è¾…åŠ©å‡½æ•° ---
function getUserId(update) {
  if (update.message) return update.message.from.id;
  if (update.callback_query) return update.callback_query.from.id;
  return null;
}

function getSevenDaysAgoISO() {
  const date = new Date();
  date.setDate(date.getDate() - 7);
  return date.toISOString();
}

// èœå•
async function sendWelcomeMenu(chatId) {
  const text = "ğŸ‘‹ æ¬¢è¿å›æ¥ï¼\n\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹æ“ä½œï¼š";
  const keyboard = {
    keyboard: [
      [{ text: "ğŸ“¦ ç«‹å³å–å·" }, { text: "ğŸ“Š æŸ¥è¯¢åº“å­˜" }],
      [{ text: "ğŸ  éšæœºåœ°å€" }]
    ],
    resize_keyboard: true,
    is_persistent: true
  };
  await sendMessage(chatId, text, keyboard);
}

// --- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ ---

// 1. å¤„ç† Redfin åœ°å€æŠ“å–
async function handleRedfinAddress(chatId, isJsonOnly = false) {
  try {
    const response = await fetch(CONFIG.REDFIN_URL, {
      headers: { 
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" 
      }
    });
    const html = await response.text();
    const addressRegex = /"streetAddress":"([^"]+)"/g;
    let matches = [];
    let match;
    while ((match = addressRegex.exec(html)) !== null) {
      matches.push(match[1]);
    }

    if (matches.length > 0) {
      const street = matches[Math.floor(Math.random() * matches.length)];
      const result = {
        address: street,
        city: CONFIG.CITY,
        state: CONFIG.STATE_FULL,
        fullAddress: `${street}, ${CONFIG.CITY}, OR ${CONFIG.ZIP_CODE}`
      };
      if (!isJsonOnly && chatId) {
        const msg = `ğŸ  <b>éšæœºæˆ¿æºåœ°å€</b>\n\nğŸ“ <code>${result.fullAddress}</code>`;
        await sendMessage(chatId, msg);
      }
      return result;
    }
    return { error: "No address found" };
  } catch (e) {
    return { error: e.message };
  }
}

// 2. å¤„ç†å–å·
async function handleGetAccount(chatId) {
  const [page, stockCount] = await Promise.all([
    queryNotionUnused(), 
    getStockCount()      
  ]);

  if (!page) {
    return sendMessage(chatId, "âš ï¸ <b>åº“å­˜ä¸è¶³</b>ï¼šå½“å‰æ²¡æœ‰â€œä¸€å‘¨å†…åˆ›å»ºâ€ä¸”â€œæœªä½¿ç”¨â€çš„è´¦å·ã€‚");
  }

  const props = page.properties;
  const pageId = page.id;

  const account = props["è´¦å·"]?.formula?.string || props["è´¦å·"]?.rich_text?.[0]?.plain_text || props["è´¦å·"]?.title?.[0]?.plain_text || "æ— è´¦å·";
  const password = props["å¯†ç "]?.formula?.string || props["å¯†ç "]?.rich_text?.[0]?.plain_text || "æ— å¯†ç ";

  let createTimeRaw = props["åˆ›å»ºæ—¶é—´"]?.created_time || props["åˆ›å»ºæ—¶é—´"]?.date?.start || "æœªçŸ¥";
  let createTimeStr = "æœªçŸ¥";
  
  if (createTimeRaw !== "æœªçŸ¥") {
    const dateObj = new Date(createTimeRaw);
    createTimeStr = dateObj.toLocaleString('zh-CN', { 
      timeZone: 'Asia/Shanghai', 
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    }).replace(/\//g, '-');
  }

  const messageText = 
    `ğŸ“¦ <b>æå–æˆåŠŸï¼</b> (ğŸ“Š æœ¬å‘¨åº“å­˜: ${stockCount})\n\n` +
    `è´¦å·ï¼š<code>${account}</code>\n` +
    `å¯†ç ï¼š<code>${password}</code>\n` +
    `Xboxåˆ›å»ºæ—¶é—´ï¼š${createTimeStr}\n\n` +
    `ğŸ‘‡ <b>è¯·é€‰æ‹©æ“ä½œï¼š</b>`;

  const inlineKeyboard = {
    inline_keyboard: [
      [
        { text: "âœ… å…‘æ¢ç ", callback_data: `redeem|${pageId}` }, 
        { text: "ğŸ”˜ å…¶ä»–", callback_data: `other|${pageId}` }
      ],
      [
        { text: "âŒ å–æ¶ˆ", callback_data: `cancel|${pageId}` }
      ]
    ]
  };

  await sendMessage(chatId, messageText, inlineKeyboard);
}

// 3. å¤„ç†åº“å­˜æŸ¥è¯¢
async function handleCheckStock(chatId) {
  const count = await getStockCount();
  const text = `ğŸ“Š <b>åº“å­˜æŸ¥è¯¢ç»“æœ</b>\n\n` +
               `ä¸€å‘¨å†…åˆ›å»ºä¸”æœªä½¿ç”¨çš„ç™½å·ï¼š<b>${count}</b> ä¸ª`;
  await sendMessage(chatId, text);
}

// 4. å¤„ç†æŒ‰é’®å›è°ƒ (ğŸ”´ æ ¸å¿ƒä¿®æ”¹éƒ¨åˆ†)
async function handleCallback(query) {
  const [action, pageId] = query.data.split("|");
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;

  if (action === "cancel") {
    await deleteMessage(chatId, messageId);
    return;
  }

  // è·å–åŸå§‹æ¶ˆæ¯æ–‡æœ¬ï¼ˆTelegram ä¼šå»æ‰æ ¼å¼ï¼‰
  let originalText = query.message.text || "";
  
  // å»æ‰åº•éƒ¨çš„ "ğŸ‘‡ è¯·é€‰æ‹©æ“ä½œï¼š" æç¤º
  originalText = originalText.replace(/ğŸ‘‡.*/s, "").trim();

  // ğŸ”„ é‡æ–°ç»™è´¦å·å’Œå¯†ç åŠ ä¸Š <code> æ ‡ç­¾ (åˆ©ç”¨æ­£åˆ™åŒ¹é…)
  // è¿™æ ·æ›´æ–°åçš„æ¶ˆæ¯ä¾ç„¶å¯ä»¥ç‚¹å‡»å¤åˆ¶
  originalText = originalText.replace(/(è´¦å·ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(å¯†ç ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(ğŸ“)(.+)/, '$1<code>$2</code>'); // é˜²æ­¢åœ°å€ä¹Ÿè¢«è¯¯ä¼¤

  // å‡†å¤‡æ–°çŠ¶æ€å’Œæ—¶é—´
  let newStatus = action === "redeem" ? "å…‘æ¢ç " : "å…¶ä»–";
  let statusText = action === "redeem" ? "âœ… <b>å·²æ ‡è®°ä¸ºï¼šå…‘æ¢ç </b>" : "ğŸ”˜ <b>å·²æ ‡è®°ä¸ºï¼šå…¶ä»–</b>";
  
  // è·å–å½“å‰æ—¶é—´
  const nowStr = new Date().toLocaleString('zh-CN', { 
    timeZone: 'Asia/Shanghai', 
    hour12: false 
  });

  const success = await updateNotionPage(pageId, newStatus);

  if (success) {
    // æ‹¼æ¥æœ€ç»ˆæ¶ˆæ¯ï¼šåŸå†…å®¹ + çŠ¶æ€ + æ—¶é—´
    const finalText = `${originalText}\n\n${statusText}\nğŸ•’ <b>ä½¿ç”¨æ—¶é—´ï¼š</b>${nowStr}`;
    
    // ç¼–è¾‘æ¶ˆæ¯ï¼ˆå»æ‰äº†æŒ‰é’®ï¼Œä¿ç•™äº†ä¿¡æ¯ï¼‰
    await editMessage(chatId, messageId, finalText);
    await answerCallback(query.id, "æ“ä½œæˆåŠŸï¼");
  } else {
    await answerCallback(query.id, "âŒ Notion æ›´æ–°å¤±è´¥");
  }
}

// --- Notion API ---

async function queryNotionUnused() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;
  const sevenDaysAgo = getSevenDaysAgoISO();

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "filter": {
        "and": [
          { "property": "çŠ¶æ€", "select": { "is_empty": true } },
          { "property": "åˆ›å»ºæ—¶é—´", "date": { "on_or_after": sevenDaysAgo } }
        ]
      },
      "sorts": [{ "property": "åˆ›å»ºæ—¶é—´", "direction": "ascending" }],
      "page_size": 1
    })
  });
  const data = await response.json();
  if (data.results && data.results.length > 0) return data.results[0];
  return null;
}

async function getStockCount() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;
  const sevenDaysAgo = getSevenDaysAgoISO();

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
        "Notion-Version": "2022-06-28",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "filter": {
          "and": [
            { "property": "çŠ¶æ€", "select": { "is_empty": true } },
            { "property": "åˆ›å»ºæ—¶é—´", "date": { "on_or_after": sevenDaysAgo } }
          ]
        },
        "page_size": 100 
      })
    });
    const data = await response.json();
    return data.results ? data.results.length : 0;
  } catch (e) {
    return "æœªçŸ¥";
  }
}

async function updateNotionPage(pageId, statusName) {
  const url = `https://api.notion.com/v1/pages/${pageId}`;
  const now = new Date().toISOString();
  const response = await fetch(url, {
    method: "PATCH",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "properties": {
        "çŠ¶æ€": { "select": { "name": statusName } },
        "ä½¿ç”¨æ—¥æœŸ": { "date": { "start": now } }
      }
    })
  });
  return response.ok;
}

// --- Telegram API ---

async function sendMessage(chatId, text, replyMarkup = null) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/sendMessage`;
  const body = { chat_id: chatId, text: text, parse_mode: "HTML" };
  if (replyMarkup) body.reply_markup = replyMarkup;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
}

async function deleteMessage(chatId, messageId) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/deleteMessage`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId }) });
}

async function editMessage(chatId, messageId, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/editMessageText`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId, text: text, parse_mode: "HTML" }) });
}

async function answerCallback(id, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/answerCallbackQuery`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ callback_query_id: id, text: text }) });
}
