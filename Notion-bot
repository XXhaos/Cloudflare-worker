/**
 * é…ç½®åŒºåŸŸ
 */
const CONFIG = {
  // Notion é…ç½®
  NOTION_DATABASE_ID: "ä¿®æ”¹ä¸ºå¯¹åº”çš„NOTION_DATABASE_ID", 
  NOTION_API_KEY: "ä¿®æ”¹ä¸ºå¯¹åº”çš„NOTION_API_KEY",

  // Telegram é…ç½®
  TELEGRAM_BOT_TOKEN: "ä¿®æ”¹ä¸ºå¯¹åº”çš„TELEGRAM_BOT_TOKEN",
  ALLOWED_USER_IDS: ["ä¿®æ”¹ä¸ºå¯¹åº”çš„ALLOWED_USER_IDS"],

  // åŸºç¡€é…ç½®
  CITY: "Portland",
  STATE_FULL: "Oregon",
  ZIP_CODE: "97212"
};

export default {
  async fetch(request, env, ctx) {
    if (request.method === "GET") {
      const data = await handleRedfinAddress(null, true);
      return new Response(JSON.stringify(data, null, 2), { 
        headers: { "Content-Type": "application/json; charset=utf-8" } 
      });
    }

    if (request.method !== "POST") return new Response("Bot is running!", { status: 200 });

    try {
      const update = await request.json();

      // --- 1. é‰´æƒ ---
      const userId = getUserId(update);
      if (userId && !CONFIG.ALLOWED_USER_IDS.includes(String(userId))) {
        return new Response("Unauthorized", { status: 200 }); 
      }

      // --- 2. æ¶ˆæ¯å¤„ç† ---
      if (update.message && update.message.text) {
        const text = update.message.text.trim();
        const chatId = update.message.chat.id;

        if (text === "/start") {
          await sendWelcomeMenu(chatId);
        }
        else if (text === "ğŸ“¦ ç«‹å³å–å·" || text === "å–å·" || text === "/get") {
          await handleGetAccount(chatId);
        }
        else if (text === "ğŸ“Š æŸ¥è¯¢åº“å­˜" || text === "åº“å­˜" || text === "/stock") {
          await handleCheckStock(chatId);
        }
        else if (text === "ğŸ  éšæœºåœ°å€" || text === "åœ°å€" || text === "/address") {
          await handleRedfinAddress(chatId);
        }
      }
      
      // --- 3. æŒ‰é’®å›è°ƒå¤„ç† ---
      else if (update.callback_query) {
        await handleCallback(update.callback_query);
      }

    } catch (e) {
      console.error(e);
    }

    return new Response("OK", { status: 200 });
  }
};

// --- è¾…åŠ©å‡½æ•° ---
function getUserId(update) {
  if (update.message) return update.message.from.id;
  if (update.callback_query) return update.callback_query.from.id;
  return null;
}

// èœå•
async function sendWelcomeMenu(chatId) {
  const text = "ğŸ‘‹ æ¬¢è¿å›æ¥ï¼\n\nè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹æ“ä½œï¼š";
  const keyboard = {
    keyboard: [
      [{ text: "ğŸ“¦ ç«‹å³å–å·" }, { text: "ğŸ“Š æŸ¥è¯¢åº“å­˜" }],
      [{ text: "ğŸ  éšæœºåœ°å€" }]
    ],
    resize_keyboard: true,
    is_persistent: true
  };
  await sendMessage(chatId, text, keyboard);
}

// --- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ ---

// 1. å¤„ç†åœ°å€æŠ“å– (OSM çº¯åœ¨çº¿ç‰ˆ - å¾ªç¯é‡è¯•æœºåˆ¶)
async function handleRedfinAddress(chatId, isJsonOnly = false) {
  // å…³é”®è¯æ± ï¼šæ··åˆäº†å•†ä¸šã€ä½å®…ã€é€šç”¨åè¯ï¼Œä¿è¯å¤šæ ·æ€§
  const searchTerms = [
      "apartments", "house", "residential", "coffee", "shop", "restaurant", 
      "school", "bakery", "pharmacy", "gym", "bank", "salon", "market", "clinic",
      "office", "center", "park", "store", "hotel", "bar", "pizza", "burger",
      "Avenue", "Street", "Place", "Court", "Drive", "Lane", "Way", "Terrace",
      "Broadway", "Main", "Central", "North", "South", "East", "West",
      "Garden", "View", "Hill", "Lake", "Plaza", "Square", "Village", "Corner"
  ];

  let lastError = null;

  // ğŸ”„ å¾ªç¯é‡è¯•æœºåˆ¶ï¼šæœ€å¤šå°è¯• 5 æ¬¡
  // å¦‚æœæŸæ¬¡å…³é”®è¯æœä¸åˆ°ï¼ˆæ¯”å¦‚æœ 'Lake' æ²¡ç»“æœï¼‰ï¼Œå¾ªç¯ä¼šè‡ªåŠ¨ç»§ç»­ä¸‹ä¸€æ¬¡ï¼Œç›´åˆ°æœåˆ°ä¸ºæ­¢
  // è¿™æ ·é¿å…äº†é€’å½’è°ƒç”¨å¯¼è‡´çš„â€œé‡è¯•æ¬¡æ•°è¿‡å¤šâ€æŠ¥é”™
  for (let attempt = 0; attempt < 5; attempt++) {
    try {
      // éšæœºé€‰ä¸€ä¸ªå…³é”®è¯
      const keyword = searchTerms[Math.floor(Math.random() * searchTerms.length)];
      
      // æ„é€  OSM æœç´¢æŸ¥è¯¢ (é™åˆ¶åœ¨ 97212)
      // limit=50 ä¿è¯ç»“æœè¶³å¤Ÿå¤šï¼Œé˜²æ­¢é‡å¤
      const osmUrl = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(keyword + " in 97212, Portland, Oregon")}&format=json&addressdetails=1&limit=50`;

      const response = await fetch(osmUrl, {
        headers: {
          "User-Agent": "RealAddressBot/5.0", // å¿…é¡»å¸¦ UA
          "Referer": "https://www.openstreetmap.org/"
        }
      });

      if (!response.ok) {
        lastError = `API Error ${response.status}`;
        continue; // ç½‘ç»œé”™è¯¯ï¼Œé‡è¯•ä¸‹ä¸€æ¬¡
      }

      const data = await response.json();

      // ä¸¥æ ¼æ¸…æ´—æ•°æ®ï¼šå¿…é¡»åŒ…å«ã€é—¨ç‰Œå·ã€‘ã€ã€è·¯åã€‘ä¸”é‚®ç¼–åŒ¹é…
      const validAddresses = data.filter(item => {
          const addr = item.address;
          return addr && 
                 addr.house_number &&  
                 addr.road &&          
                 addr.postcode &&      
                 addr.postcode.includes("97212");
      });

      // å¦‚æœå½“å‰å…³é”®è¯æœä¸åˆ°ç»“æœï¼Œcontinue ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯
      if (validAddresses.length === 0) {
          continue;
      }

      // --- æˆåŠŸè·å–ï¼---
      
      // éšæœºæŠ½å–ä¸€ä¸ª
      const randomPlace = validAddresses[Math.floor(Math.random() * validAddresses.length)];
      const addr = randomPlace.address;

      // æ ¼å¼åŒ–åœ°å€
      const street = `${addr.house_number} ${addr.road}`;
      const city = addr.city || addr.town || "Portland";
      const state = "OR";
      const zip = "97212";

      const fullAddr = `${street}, ${city}, ${state} ${zip}`;

      const result = {
        address: street,
        city: city,
        state: state,
        zip: zip,
        fullAddress: fullAddr
      };

      if (!isJsonOnly && chatId) {
        const msg = `ğŸ  <b>éšæœºæˆ¿æºåœ°å€</b>\n\nğŸ“ <code>${result.fullAddress}</code>`;
        await sendMessage(chatId, msg);
      }

      return result; // æˆåŠŸè¿”å›ï¼Œç»“æŸå‡½æ•°

    } catch (e) {
      lastError = e.message;
      // æ•è·å¼‚å¸¸ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯å°è¯•
    }
  }

  // --- å¦‚æœ 5 æ¬¡å¾ªç¯å…¨éƒ¨å¤±è´¥ ---
  // è¿™é‡Œå¿…é¡»æŠ¥é”™ï¼Œå› ä¸ºä½ ä¸å…è®¸ç”Ÿæˆå‡åœ°å€
  if (chatId) {
     await sendMessage(chatId, `âŒ <b>è·å–å¤±è´¥:</b> åœ¨çº¿æœç´¢æ— ç»“æœ (å·²é‡è¯•5æ¬¡)ï¼Œè¯·ç¨åå†è¯•ã€‚`);
  }
  return { error: "Failed to fetch online address after 5 attempts" };
}

// 2. å¤„ç†å–å· (å·²ä¿®å¤â€œç»„åˆâ€ä¸¢å¤±çš„é—®é¢˜)
async function handleGetAccount(chatId) {
  const [page, stockCount] = await Promise.all([
    queryNotionUnused(), 
    getStockCount()      
  ]);

  if (!page) {
    return sendMessage(chatId, "âš ï¸ <b>åº“å­˜ä¸è¶³</b>ï¼šå½“å‰æ²¡æœ‰â€œæœªä½¿ç”¨â€çš„è´¦å·ã€‚");
  }

  const props = page.properties;
  const pageId = page.id;

  const account = props["è´¦å·"]?.formula?.string || props["è´¦å·"]?.rich_text?.[0]?.plain_text || props["è´¦å·"]?.title?.[0]?.plain_text || "æ— è´¦å·";
  const password = props["å¯†ç "]?.formula?.string || props["å¯†ç "]?.rich_text?.[0]?.plain_text || "æ— å¯†ç ";

  // è¯»å–åˆ›å»ºæ—¶é—´
  let createTimeRaw = props["åˆ›å»ºæ—¶é—´"]?.created_time || props["åˆ›å»ºæ—¶é—´"]?.date?.start || "æœªçŸ¥";
  let createTimeStr = "æœªçŸ¥";
  
  if (createTimeRaw !== "æœªçŸ¥") {
    const dateObj = new Date(createTimeRaw);
    createTimeStr = dateObj.toLocaleString('zh-CN', { 
      timeZone: 'Asia/Shanghai', 
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    }).replace(/\//g, '-');
  }

  const messageText = 
    `ğŸ“¦ <b>æå–æˆåŠŸï¼</b> (ğŸ“Š åº“å­˜: ${stockCount})\n\n` +
    `è´¦å·ï¼š<code>${account}</code>\n` +
    `å¯†ç ï¼š<code>${password}</code>\n` +
    `ç»„åˆï¼š<code>${account}----${password}</code>\n` + 
    `Xboxåˆ›å»ºæ—¶é—´ï¼š${createTimeStr}\n\n` +
    `ğŸ‘‡ <b>è¯·é€‰æ‹©æ“ä½œï¼š</b>`;

  const inlineKeyboard = {
    inline_keyboard: [
      [
        { text: "âœ… å…‘æ¢ç ", callback_data: `redeem|${pageId}` }, 
        { text: "ğŸ”˜ å…¶ä»–", callback_data: `other|${pageId}` }
      ],
      [
        { text: "âŒ å–æ¶ˆ", callback_data: `cancel|${pageId}` }
      ]
    ]
  };

  await sendMessage(chatId, messageText, inlineKeyboard);
}

// 3. å¤„ç†åº“å­˜æŸ¥è¯¢
async function handleCheckStock(chatId) {
  const count = await getStockCount();
  const text = `ğŸ“Š <b>åº“å­˜æŸ¥è¯¢ç»“æœ</b>\n\n` +
               `å½“å‰å‰©ä½™å¯ç”¨ç™½å·ï¼š<b>${count}</b> ä¸ª`;
  await sendMessage(chatId, text);
}

// 4. å¤„ç†æŒ‰é’®å›è°ƒ
async function handleCallback(query) {
  const [action, pageId] = query.data.split("|");
  const chatId = query.message.chat.id;
  const messageId = query.message.message_id;

  if (action === "cancel") {
    await deleteMessage(chatId, messageId);
    return;
  }

  let originalText = query.message.text || "";
  originalText = originalText.replace(/ğŸ‘‡.*/s, "").trim();

  // ğŸ”„ é‡æ–°ç»™è´¦å·ã€å¯†ç ã€ç»„åˆã€åœ°å€åŠ ä¸Š <code> æ ‡ç­¾
  originalText = originalText.replace(/(è´¦å·ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(å¯†ç ï¼š)(.+)/, '$1<code>$2</code>');
  originalText = originalText.replace(/(ç»„åˆï¼š)(.+)/, '$1<code>$2</code>'); 
  originalText = originalText.replace(/(ğŸ“)(.+)/, '$1<code>$2</code>'); 

  let newStatus = action === "redeem" ? "å…‘æ¢ç " : "å…¶ä»–";
  let statusText = action === "redeem" ? "âœ… <b>å·²æ ‡è®°ä¸ºï¼šå…‘æ¢ç </b>" : "ğŸ”˜ <b>å·²æ ‡è®°ä¸ºï¼šå…¶ä»–</b>";
  
  const nowStr = new Date().toLocaleString('zh-CN', { 
    timeZone: 'Asia/Shanghai', 
    hour12: false 
  });

  const success = await updateNotionPage(pageId, newStatus);

  if (success) {
    const finalText = `${originalText}\n\n${statusText}\nğŸ•’ <b>ä½¿ç”¨æ—¶é—´ï¼š</b>${nowStr}`;
    await editMessage(chatId, messageId, finalText);
    await answerCallback(query.id, "æ“ä½œæˆåŠŸï¼");
  } else {
    await answerCallback(query.id, "âŒ Notion æ›´æ–°å¤±è´¥");
  }
}

// --- Notion API ---

async function queryNotionUnused() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "filter": { "property": "çŠ¶æ€", "select": { "is_empty": true } }, // ä»…ç­›é€‰ç©ºçŠ¶æ€
      "sorts": [{ "property": "åˆ›å»ºæ—¶é—´", "direction": "ascending" }],
      "page_size": 1
    })
  });
  const data = await response.json();
  if (data.results && data.results.length > 0) return data.results[0];
  return null;
}

async function getStockCount() {
  const url = `https://api.notion.com/v1/databases/${CONFIG.NOTION_DATABASE_ID}/query`;

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
        "Notion-Version": "2022-06-28",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "filter": { "property": "çŠ¶æ€", "select": { "is_empty": true } }, // ä»…ç­›é€‰ç©ºçŠ¶æ€
        "page_size": 100 
      })
    });
    const data = await response.json();
    return data.results ? data.results.length : 0;
  } catch (e) {
    return "æœªçŸ¥";
  }
}

async function updateNotionPage(pageId, statusName) {
  const url = `https://api.notion.com/v1/pages/${pageId}`;
  const now = new Date().toISOString();
  const response = await fetch(url, {
    method: "PATCH",
    headers: {
      "Authorization": `Bearer ${CONFIG.NOTION_API_KEY}`,
      "Notion-Version": "2022-06-28",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "properties": {
        "çŠ¶æ€": { "select": { "name": statusName } },
        "ä½¿ç”¨æ—¥æœŸ": { "date": { "start": now } }
      }
    })
  });
  return response.ok;
}

// --- Telegram API ---

async function sendMessage(chatId, text, replyMarkup = null) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/sendMessage`;
  const body = { chat_id: chatId, text: text, parse_mode: "HTML" };
  if (replyMarkup) body.reply_markup = replyMarkup;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
}

async function deleteMessage(chatId, messageId) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/deleteMessage`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId }) });
}

async function editMessage(chatId, messageId, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/editMessageText`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ chat_id: chatId, message_id: messageId, text: text, parse_mode: "HTML" }) });
}

async function answerCallback(id, text) {
  const url = `https://api.telegram.org/bot${CONFIG.TELEGRAM_BOT_TOKEN}/answerCallbackQuery`;
  await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ callback_query_id: id, text: text }) });
}
